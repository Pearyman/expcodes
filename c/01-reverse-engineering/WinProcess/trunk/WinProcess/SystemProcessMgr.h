#pragma once

#include "stdafx.h"
#include "utils_os.h"

#include <Windows.h>
#include <string>
#include <map>
#include <list>
using namespace std;

// 无效的进程号(系统进程号为0, DWORD为无符号整型，只能取最大值)
const static DWORD INVAILD_PID = 0xFFFFFFFF;


/************************************************************************/
/* 单个进程的信息对象                                                   */
/************************************************************************/ 
class Process {
	public:
		DWORD pid;
		string pName;
		bool isX64;

		Process(): pid(INVAILD_PID), pName(""), isX64(false) {}

		bool operator == (const Process& other) {
			return (this == &other || this->pid == other.pid);
		}

		bool operator != (const Process& other) {
			return !(operator == (other));
		}
};

// 默认的空进程对象
static Process INVAILD_PROCESS;


/************************************************************************/
/* 单个进程内的所有模块对象                                             */
/************************************************************************/ 
class ProcessModule : public Process {
	public:
		int mCnt;					// 模块个数
		DWORD mSize;				// modBaseSize 单个模块大小（字节）
		DWORD mID;					// th32ModuleID, 此成员已经不再被使用，通常被设置为1
		DWORD usage;				// GlblcntUsage 或 ProccntUsage 全局模块的使用计数，即模块的总载入次数。通常这一项是没有意义的
		BYTE* baseAddr;				// modBaseAddr 模块基址（在所属进程范围内）
		HMODULE hModule;			// hModule 模块句柄地址（在所属进程范围内）
		list<string>* mNames;		// szModule[MAX_MODULE_NAME32 + 1];	 NULL结尾的字符串，其中包含模块名。
		list<string>* mPaths;		// szExePath[MAX_PATH];	 NULL结尾的字符串，其中包含的位置，或模块的路径。

		ProcessModule() : Process(), 
			mCnt(0), mSize(0), mID(0), usage(0), baseAddr(NULL), hModule(NULL) {
			this->mNames = new list<string>();
			this->mPaths = new list<string>();
		}

		~ProcessModule() {
			clear();
			delete mNames; mNames = NULL;
			delete mPaths; mPaths = NULL;
		}

	private:
		void clear();
};

// 默认的空进程模块对象
static ProcessModule INVAILD_PROCESS_MODULE;


/************************************************************************/
/* 系统进程集管理对象                                                   */
/************************************************************************/ 
class SystemProcessMgr
{
	public:
		SystemProcessMgr() {
			this->IS_X64_OS = OS_UTILS::isX64();
			this->processMap = new map<DWORD, Process>();
			this->pids = new DWORD[1];
			this->processes = new Process*[1];
			this->processModule = new ProcessModule();
		}

		~SystemProcessMgr() {
			clearProcesses();
			delete processMap; processMap = NULL;
			delete[] pids; pids = NULL;
			delete[] processes; processes = NULL;
			delete processModule; processModule = NULL;
		}

		bool reflashProcessList();
		const Process& getProcess(DWORD pid);

		DWORD* getAllPIDs();
		Process** getAllProcesses();	// 获取所有进程对象的地址数组
		ProcessModule* getProcessModuleInfo(DWORD pid);	// 获取进程模块信息

	protected:
		bool traverseProcesses();
		void clearProcesses();

		const Process& addProcess(DWORD pid, string pName);
		bool isX64Process(DWORD pid);
		static bool compare(Process* aProc, Process* bProc);	// 类内的sort比较函数必须是静态

	private:
		bool IS_X64_OS;
		map<DWORD, Process>* processMap;	// 当前进程表
		DWORD* pids;						// 当前进程对象号数组
		Process** processes;				// 当前进程对象的指针数组
		ProcessModule* processModule;		// 当前选中的进程模块指针
};


////在psaipi.dll中的函数EnumProcesses用来枚举进程 
//typedef BOOL (_stdcall *ENUMPROCESSES)(  //注意这里要指明调用约定为-stdcall
//	DWORD* pProcessIds,  //指向进程ID数组链  
//	DWORD cb,    //ID数组的大小，用字节计数
//	DWORD* pBytesReturned);   //返回的字节
//
////在psapi.dll中的函数EnumProcessModules用来枚举进程模块
//typedef BOOL (_stdcall *ENUMPROCESSMODULES)(
//	HANDLE hProcess,   //进程句柄
//	HMODULE* lphModule, //指向模块句柄数组链
//	DWORD cb,    //模块句柄数组大小，字节计数
//	LPDWORD lpcbNeeded);   //存储所有模块句柄所需的字节数
//
////在psapi.dll中的函数GetModuleFileNameEx获得进程模块名
//typedef DWORD (_stdcall *GETMODULEFILENAMEEX)(
//	HANDLE hProcess,   //进程句柄
//	HMODULE hModule,   //进程模块句柄
//	LPTSTR lpFilename,   //存放模块全路径名
//	DWORD nSize    //lpFilename缓冲区大小，字符计算
//	);