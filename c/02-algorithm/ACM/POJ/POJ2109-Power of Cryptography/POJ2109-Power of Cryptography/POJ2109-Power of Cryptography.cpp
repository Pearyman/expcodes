/*
	Author:     Exp
	Date:       2017-12-07
	Code:       POJ 2109
	Problem:    Power of Cryptography
	URL:		http://poj.org/problem?id=2109
*/

/*
	【题意分析】
	   有指数函数 k^n = p ，
	   其中k、n、p均为整数且 1<=n<= 200 , 1<=p<10^101 , 1<=k<=10^9
	   给定 n 和 p ，求底数 k

	【解题思路】
	   考虑到数值存储问题和精度问题，这题最直观的思路应该是使用 高精度算法 求解。
	   而事实上，这题也可用公式法求解，但需要一些技巧。


	   开方公式：n = k-sqrt(p)
	   但C++的数学函数库并没有提供k次方的开方函数，此时需要转换一下公式：
	   n = p^(1/k)
	   对p开k次方等价于求p的1/k次方，此时我们就可以用pow函数求解了：
	   n = pow(p, 1.0/k)




	这题其实最大漏洞就在于k的范围被限制在了1<=k<=10^9内。
	double的有效数字是15~16位，也就是说将p塞进double误差率在10^-15数量级左右。
	而开n次根号误差率是只会减小不会增大的，塞回double误差率仍然是10^-15左右的数量级。
	而答案只可能有9位有效数字，显然这个误差率只会影响到小数部分而不会对整数部分有影响，
	四舍五入之后就能得到结果。
	如果这题没有限定整数k的范围，那这个解答显然就不能通过，只要p很大而n很小就无法得到正确结果。

	首先需要明确：double类型虽然能表示10^(-307)~10^308, （远大于题意的1<=p<10^101这个范围）,
	但只能精确前16位，因此必须慎用！
	那么为了避免double对输入的数在运算过程中进行精确，
	那么我们必须让double的运算第一步就得到一个int（即小数点尾数全为0），这个不难理解。

	然后根据题意，是求指数k，一般人自然想到利用 对数log，即k=lognp。
	但是不要忘记使用对数最大的问题就是没有lognp函数，只有log()函数（底数为e），
	为此要计算lognp就必须使用换底公式lognp=log(p)/log(n),即k= log(p)/log(n)，
	由于这使得double的运算变为了3次，而且执行除法前的两次对数运算log的结果未必都是int，
	很显然k是一个被精确了的double

	很多人到这里就放弃了使用double，转换方向到正常思路（二分+高精度算法），
	但是不要忘记求指数k除了使用对数log，还能使用指数的倒数开n次方，这时就可以用pow函数了
	k=pow(p,1.0/n)，double的运算一步到位，k自然也是一个int

*/

#include <math.h>
#include <iostream>
using namespace std;

int main(void) {
	double k, n , p;


	return 0;
}